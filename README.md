# Tochka Delivery Telegram Bot

## Назначение
Бот автоматизирует обмен заданиями между администраторами и курьерами службы доставки «Точка». Администраторы выгружают XLSX-файлы с карточками заказов, бот распределяет их между курьерами, сохраняет историю отправок и ведет аудит действий. Курьеры передают контактные данные, получают задания и могут повторно запросить последние карточки.

## Системные требования
- Node.js версии 18 или выше.
- Telegraf v4 (добавляется как зависимость npm).
- npm 9+ или совместимый менеджер пакетов для установки зависимостей.

## Подготовка окружения
1. Склонируйте репозиторий и установите зависимости:
   ```bash
   npm install
   ```
2. Задайте переменные окружения (минимально необходимо передать токен — через конфиг или переменную `BOT_TOKEN`). Пример `.env`:
   ```bash
   cp .env.example .env   # если файл примера присутствует; иначе создайте вручную
   cat <<'EOF' >> .env
   BOT_TOKEN=123456:ABC
   BOT_MODE=polling            # или webhook
   # Параметры webhook-режима (используются, если BOT_MODE=webhook):
   # BOT_WEBHOOK_URL=https://example.com/telegram
   # BOT_WEBHOOK_SECRET=change-me
   # BOT_WEBHOOK_PORT=8443
   # BOT_WEBHOOK_HOST=0.0.0.0
   # BOT_WEBHOOK_PATH=/telegraf
   # Параметры long polling (опционально):
   # BOT_POLLING_TIMEOUT=30
   # BOT_POLLING_LIMIT=100
   # BOT_POLLING_ALLOWED_UPDATES=message,callback_query
   # BOT_POLLING_DROP_PENDING=false
   EOF
   ```
   Директории и другие пути можно переопределять переменными `BOT_DATA_DIR`, `BOT_BACKUP_DIR`, `BOT_LOG_DIR`, `BOT_SCHEMA_FILE`, а также `BACKUP_RETENTION`.

### Несовместимые изменения конфигурации

Версия ветки `work` объединяет настройки старой схемы и нового конфигуратора бота. Чтобы перейти на неё:

- Переместите значения из полей `botToken` и `botMode` в объект `bot.token` и `bot.mode`.
- Настройки `polling` и `webhook` теперь находятся внутри `bot.polling` и `bot.webhook` соответственно.
- Остальные пути (`dataDir`, `backupDir`, `logDir`, `backupRetention`, `schemaFile`) остались на верхнем уровне, поэтому их перенос не требуется.

3. При необходимости отредактируйте `config/default.json` или создайте собственный конфиг. Итоговая структура файла такова:

   ```json
   {
     "$schema": "./schema.json",
     "dataDir": "./data",
     "backupDir": "./backups",
     "logDir": "./logs",
     "backupRetention": 20,
     "schemaFile": "./data/schema.json",
     "bot": {
       "token": "",
       "mode": "polling",
       "polling": {
         "timeout": 30,
         "limit": 100,
         "allowedUpdates": [],
         "dropPendingUpdates": false
       },
       "webhook": {
         "url": "",
         "secret": "",
         "port": 8443,
         "host": "0.0.0.0",
         "path": "/telegraf"
       }
     }
   }
   ```

   Поле `bot.token` можно оставить пустым и задавать секрет через переменную окружения `BOT_TOKEN`. Порядок переопределений следующий: значения из переменных окружения → значения из пользовательского JSON-конфига → значения по умолчанию из `config/default.json`.

   Можно задать альтернативный путь к конфигу через `BOT_CONFIG_PATH`, а любые поля переопределить соответствующими переменными окружения (`BOT_MODE`, `BOT_WEBHOOK_URL` и т.д.).

4. Создайте каталоги для данных и журналов. По умолчанию приложение использует подкаталоги от рабочей директории процесса
   (настройки берутся из конфигурации):
   ```text
   data/       # рабочие JSON-файлы (смонтируйте или создайте симлинк на storage/)
   backups/    # архивы JSON с временными метками
   logs/       # аудиторский журнал audit.log
   ```
   > Совет: если бот запускается в контейнере, примонтируйте внешние тома к `data/`, `backups/` и `logs/`, а затем создайте симлинк `storage -> data`, чтобы сохранить совместимость с путями по умолчанию (`storage/` используется кодом для чтения/записи JSON).
5. Запустите проверки и поднимите бота:
   ```bash
   npm run build    # линт + синтаксическая проверка
   npm start        # запуск бота в Node.js
   ```
   Для разработки можно использовать нативный watch-режим Node.js:
   ```bash
   npm run dev
   ```

   Дополнительно доступна команда статического анализа:
   ```bash
   npm run lint
   ```

## Структура рабочих данных
После первого запуска в каталоге `data/` (или `storage/`, если используется симлинк либо переопределение в конфиге) будут лежать JSON-файлы:
- `couriers.json` — профиль курьеров, история последних отправленных карточек и настройки рассылок.
- `admins.json` — профиль администраторов и привязки групп для анонсов.
- `deliveries.json` — журнал всех карточек, отправленных курьерам, с отчетами об успешных/неуспешных доставках.
- `announcements.json` — история групповых анонсов, опубликованных администраторами.

Каждое сохранение создает резервную копию в каталоге `backups/` с шаблоном имени `<file>.YYYYMMDD-HHmmss.json`.

## Восстановление из резервных копий
Процедура одинакова для всех рабочих файлов, различается только название целевого JSON. Ниже приведен алгоритм и особенности для каждого типа:

1. **Выбор бэкапа.**
   - Просмотрите доступные файлы: `ls backups/couriers.json.*.json` (замените имя).
   - Подберите резервную копию по временной метке `YYYYMMDD-HHmmss`, которая предшествует инциденту.

2. **Проверка структуры.**
   - Выполните валидацию через `node` или `jq`:
     ```bash
     node -e "const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8')); console.log(Array.isArray(data) ? 'array' : typeof data);" backups/<name>.json
     ```
   - Сверьтесь с ожидаемыми ключами из схемы (см. ниже по файлам). Ошибка парсинга или лишние поля — повод выбрать другой бэкап.

3. **Атомарное восстановление.**
   - Скопируйте резервную копию во временный файл в каталоге данных: `cp backups/<name>.json data/<target>.json.tmp`.
   - Зафиксируйте запись на диск: `node -e "const fs=require('fs'); const fd=fs.openSync(process.argv[1],'r'); fs.fsyncSync(fd); fs.closeSync(fd);" data/<target>.json.tmp`.
   - Перезапишите рабочий файл атомарным переименованием: `mv data/<target>.json.tmp data/<target>.json`.
   - Выполните fsync каталога (Linux): `node -e "const fs=require('fs'); const fd=fs.openSync(process.argv[1],'r'); fs.fsyncSync(fd); fs.closeSync(fd);" data`.

4. **Права доступа.**
   - Убедитесь, что файлы имеют режим `600`, а каталоги — `700`: `chmod 600 data/<target>.json`.
   - Если каталоги смонтированы внешними томами, повторно проверьте владельца (обычно пользователь процесса Node.js).

### Детали по конкретным файлам
- **`couriers.json`** — объект, где ключи соответствуют `telegramId` курьера. Значения должны содержать `adminIds`, `lastCards` и флаг `awaitingFullName`.
- **`admins.json`** — объект с ключами-идентификаторами администраторов, включает `groupBindings` (список чатов) и временные метки `createdAt`/`updatedAt`.
- **`deliveries.json`** — массив карточек. Каждая карточка содержит `id`, `adminId`, сведения о клиенте и статус `sent | failed | pending`.
- **`announcements.json`** — массив анонсов с `adminId`, объектом `target` (chatId, title, при необходимости messageThreadId), текстом и `sentAt`.

После восстановления перезапустите бота (`npm start` или systemd) и убедитесь, что новые записи снова создают резервные копии.

## Работа с ботом
### Общие команды
- `/help` — краткая справка по базовым действиям для администраторов и курьеров.

### Для администраторов
- `/get_admin` — регистрация администратора и получение инструкций по выгрузке.
- Загрузка XLSX: отправьте файл в чат, бот распарсит карточки, сопоставит курьеров по телефону и отправит задания. После обработки приходит текстовый отчет (успехи/ошибки, отсутствующие курьеры).
- `/bind_group` — привязка групповых чатов. Перешлите сообщение из целевого чата одновременно с командой; бот сохранит связку и предложит выбрать топик при необходимости.
- `/announce` — запуск мастера анонсов. Можно указать текст сразу после команды или отправить позже, выбрав чат из клавиатуры. История публикаций сохраняется в `announcements.json`.

### Для курьеров
- `/start` — первичная регистрация, бот запросит контакт (кнопка «Поделиться номером телефона») и ФИО.
- `/reset` — очистка сохраненных данных, если нужно заново пройти регистрацию.
- `/cards` или кнопка «Получить последнее задание» (если настроена клавиатура) — повторная выдача последних карточек (до 5 последних записей).
- Отправка номера через кнопку контакта и ввод ФИО текстом завершают процесс регистрации, после чего курьер начинает получать карточки от администраторов.

## Ведение журналов и аудит
Бот пишет каждое значимое действие в `logs/audit.log` (JSON-строки с временной меткой). Логи можно собирать в централизованную систему, примонтировав каталог `logs/` в отдельный том.
