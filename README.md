# Tochka Delivery Telegram Bot

## Назначение
Бот автоматизирует обмен заданиями между администраторами и курьерами службы доставки «Точка». Администраторы выгружают XLSX-файлы с карточками заказов, бот распределяет их между курьерами, сохраняет историю отправок и ведет аудит действий. Курьеры передают контактные данные, получают задания и могут повторно запросить последние карточки.

## Системные требования
- Node.js версии 16.20.2 или выше (проект протестирован на 16.20.2 и 20.x; более ранние патчи 16-й ветки без глобального `fetch` не поддерживаются).
- npm 8+ или совместимый менеджер пакетов для установки зависимостей.
- Telegraf v4 и [node-fetch](https://github.com/node-fetch/node-fetch) — библиотека HTTP-клиента, через которую загрузчик XLSX обращается к API Telegram. Для Node.js 16 автоматически подключается полифилл Web Streams, поэтому дополнительные флаги запуска не требуются.

## Подготовка окружения
1. Склонируйте репозиторий и установите зависимости (при необходимости переключитесь на Node.js 16.20.2 командой `nvm use 16.20.2`):
   ```bash
   npm install
   ```
2. Задайте переменные окружения (минимально необходимо передать токен — через конфиг или переменную `BOT_TOKEN`). Пример `.env`:
   ```bash
   cp .env.example .env   # если файл примера присутствует; иначе создайте вручную
   cat <<'EOF' >> .env
   BOT_TOKEN=123456:ABC
   BOT_MODE=polling            # или webhook
   # Параметры webhook-режима (используются, если BOT_MODE=webhook):
   # BOT_WEBHOOK_URL=https://example.com/telegram
   # BOT_WEBHOOK_SECRET=change-me
   # BOT_WEBHOOK_PORT=8443
   # BOT_WEBHOOK_HOST=0.0.0.0
   # BOT_WEBHOOK_PATH=/telegraf
   # Параметры long polling (опционально):
   # BOT_POLLING_TIMEOUT=30
   # BOT_POLLING_LIMIT=100
   # BOT_POLLING_ALLOWED_UPDATES=message,callback_query
   # BOT_POLLING_DROP_PENDING=false
   EOF
   ```
   Директории и другие пути можно переопределять переменными `BOT_DATA_DIR`, `BOT_BACKUP_DIR`, `BOT_LOG_DIR`, `BOT_SCHEMA_FILE`, а также `BACKUP_RETENTION`.

### Несовместимые изменения конфигурации

Версия ветки `work` объединяет настройки старой схемы и нового конфигуратора бота. Чтобы перейти на неё:

- Переместите значения из полей `botToken` и `botMode` в объект `bot.token` и `bot.mode`.
- Настройки `polling` и `webhook` теперь находятся внутри `bot.polling` и `bot.webhook` соответственно.
- Остальные пути (`dataDir`, `backupDir`, `logDir`, `backupRetention`, `schemaFile`) остались на верхнем уровне, поэтому их перенос не требуется.

3. При необходимости отредактируйте `config/default.json` или создайте собственный конфиг. Итоговая структура файла такова:

   ```json
   {
     "$schema": "./schema.json",
     "dataDir": "./data",
     "backupDir": "./backups",
     "logDir": "./logs",
     "backupRetention": 20,
     "schemaFile": "./data/schema.json",
     "bot": {
       "token": "",
       "mode": "polling",
       "polling": {
         "timeout": 30,
         "limit": 100,
         "allowedUpdates": [],
         "dropPendingUpdates": false
       },
       "webhook": {
         "url": "",
         "secret": "",
         "port": 8443,
         "host": "0.0.0.0",
         "path": "/telegraf"
       }
     }
   }
   ```

   Поле `bot.token` можно оставить пустым и задавать секрет через переменную окружения `BOT_TOKEN`. Порядок переопределений следующий: значения из переменных окружения → значения из пользовательского JSON-конфига → значения по умолчанию из `config/default.json`.

   Можно задать альтернативный путь к конфигу через `BOT_CONFIG_PATH`, а любые поля переопределить соответствующими переменными окружения (`BOT_MODE`, `BOT_WEBHOOK_URL` и т.д.).

4. Создайте каталоги для данных и журналов. По умолчанию приложение использует подкаталоги от рабочей директории процесса
   (настройки берутся из конфигурации):
   ```text
   data/       # рабочие JSON-файлы (смонтируйте или создайте симлинк на storage/)
   backups/    # архивы JSON с временными метками
   logs/       # аудиторский журнал audit.log
   ```
   > Совет: если бот запускается в контейнере, примонтируйте внешние тома к `data/`, `backups/` и `logs/`, а затем создайте симлинк `storage -> data`, чтобы сохранить совместимость с путями по умолчанию (`storage/` используется кодом для чтения/записи JSON).
5. Запустите проверки и поднимите бота (команды протестированы на Node.js 16.20.2 и 20.x):
   ```bash
   npm run lint     # статический анализ кода
   npm test         # модульные и интеграционные тесты
   npm start        # запуск бота напрямую в Node.js
   ```
   Для разработки доступен режим автоматического перезапуска:
   ```bash
   npm run dev
   ```

   Скрипт `npm run dev` использует `nodemon`, поэтому изменения в исходных `.js`-файлах автоматически перезапустят процесс.
   Конфигурация `nodemon.json` исключает каталоги `data/`, `backups/` и `logs/`, благодаря чему записи отчетов и резервных копий не
   приводят к повторному запуску бота во время обработки XLSX.

   Дополнительно доступна команда статического анализа:
   ```bash
   npm run lint
   ```

## Тестирование

В проекте используется [Vitest](https://vitest.dev/) c конфигурацией для ESM.
Тесты запускаются в изолированном окружении без реального I/O: обращения к файловой системе перенаправляются в виртуальное хранилище на базе `memfs`, а отправка сообщений в Telegram эмулируется через тестовый контекст `Telegraf`.
Это позволяет воспроизводить сценарии записи бэкапов, рассылки карточек и парсинга XLSX без внешних зависимостей.
Для контроля совместимости с Node.js 16 выполните тесты после переключения окружения командой `nvm use 16.20.2`.
Чек-лист ручных сценариев и пошаговое руководство по запуску на старых версиях Node собраны в [docs/node16-compatibility.md](docs/node16-compatibility.md).

Чтобы выполнить тесты локально, запустите:

```bash
npm test
```

## Структура рабочих данных
После первого запуска в каталоге `data/` (или `storage/`, если используется симлинк либо переопределение в конфиге) будут лежать JSON-файлы:
- `couriers.json` — профиль курьеров, история последних отправленных карточек и настройки рассылок.
- `admins.json` — профиль администраторов и привязки групп для анонсов.
- `deliveries.json` — журнал всех карточек, отправленных курьерам, с отчетами об успешных/неуспешных доставках.
- `announcements.json` — история групповых анонсов, опубликованных администраторами.

Каждое сохранение создает резервную копию в каталоге `backups/` с шаблоном имени `<file>.YYYYMMDD-HHmmss.json`.

### Схема валидации данных

Все рабочие JSON-файлы валидируются по общей схеме `data/schema.json`. Она опубликована с идентификатором `$id` — `https://tochka-bot.dev/schemas/data.json`, поэтому все ссылки `$ref` внутри описаний стор указывают на один и тот же документ. В корне хранятся:

- `definitions` — переиспользуемые структуры (карточка курьера, привязка чата и т.д.).
- `stores` — отдельные объекты с описанием каждого хранилища (`users`, `adminTables`, `deliveries`, `groupBindings`, `announcements`).

Чтобы расширить схему, добавьте новую сущность в раздел `definitions` (если она нужна в нескольких местах) и опишите сам стор в `stores.<имя>`, используя `$ref` на общий `$id` (`"$ref": "https://tochka-bot.dev/schemas/data.json#/definitions/<name>"`). Ajv автоматически подтянет базовую схему по этому идентификатору, поэтому дополнительные настройки загрузчика не требуются.

## Восстановление из резервных копий
Процедура одинакова для всех рабочих файлов, различается только название целевого JSON. Ниже приведен алгоритм и особенности для каждого типа:

1. **Выбор бэкапа.**
   - Просмотрите доступные файлы: `ls backups/couriers.json.*.json` (замените имя).
   - Подберите резервную копию по временной метке `YYYYMMDD-HHmmss`, которая предшествует инциденту.

2. **Проверка структуры.**
   - Выполните валидацию через `node` или `jq`:
     ```bash
     node -e "const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8')); console.log(Array.isArray(data) ? 'array' : typeof data);" backups/<name>.json
     ```
   - Сверьтесь с ожидаемыми ключами из схемы (см. ниже по файлам). Ошибка парсинга или лишние поля — повод выбрать другой бэкап.

3. **Атомарное восстановление.**
   - Скопируйте резервную копию во временный файл в каталоге данных: `cp backups/<name>.json data/<target>.json.tmp`.
   - Зафиксируйте запись на диск: `node -e "const fs=require('fs'); const fd=fs.openSync(process.argv[1],'r'); fs.fsyncSync(fd); fs.closeSync(fd);" data/<target>.json.tmp`.
   - Перезапишите рабочий файл атомарным переименованием: `mv data/<target>.json.tmp data/<target>.json`.
   - Выполните fsync каталога (Linux): `node -e "const fs=require('fs'); const fd=fs.openSync(process.argv[1],'r'); fs.fsyncSync(fd); fs.closeSync(fd);" data`.

4. **Права доступа.**
   - Убедитесь, что файлы имеют режим `600`, а каталоги — `700`: `chmod 600 data/<target>.json`.
   - Если каталоги смонтированы внешними томами, повторно проверьте владельца (обычно пользователь процесса Node.js).

### Детали по конкретным файлам
- **`couriers.json`** — объект, где ключи соответствуют `telegramId` курьера. Значения должны содержать `adminIds`, `lastCards` и флаг `awaitingFullName`.
- **`admins.json`** — объект с ключами-идентификаторами администраторов, включает `groupBindings` (список чатов) и временные метки `createdAt`/`updatedAt`.
- **`deliveries.json`** — массив карточек. Каждая карточка содержит `id`, `adminId`, сведения о клиенте и статус `sent | failed | pending`.
- **`announcements.json`** — массив анонсов с `adminId`, объектом `target` (chatId, title, при необходимости messageThreadId), текстом и `sentAt`.

После восстановления перезапустите бота (`npm start` или systemd) и убедитесь, что новые записи снова создают резервные копии.

## Работа с ботом
### Общие команды
- `/help` — краткая справка по базовым действиям для администраторов и курьеров.

### Для администраторов
- `/get_admin` — регистрация администратора и получение инструкций по выгрузке.
- Загрузка XLSX: отправьте файл в чат, бот распарсит карточки, сопоставит курьеров по телефону и отправит задания. После обработки приходит текстовый отчет (успехи/ошибки, отсутствующие курьеры).
- `/bind_group` — привязка групповых чатов. Перешлите сообщение из целевого чата одновременно с командой; бот сохранит связку и предложит выбрать топик при необходимости.
- `/announce` — запуск мастера анонсов. Можно указать текст сразу после команды или отправить позже, выбрав чат из клавиатуры. История публикаций сохраняется в `announcements.json`.

### Для курьеров
- `/start` — первичная регистрация, бот запросит контакт (кнопка «Поделиться номером телефона») и ФИО.
- `/reset` — очистка сохраненных данных, если нужно заново пройти регистрацию.
- `/cards` или кнопка «Получить последнее задание» (если настроена клавиатура) — повторная выдача последних карточек (до 5 последних записей).
- Отправка номера через кнопку контакта и ввод ФИО текстом завершают процесс регистрации, после чего курьер начинает получать карточки от администраторов.

## Ведение журналов и аудит
Бот пишет каждое значимое действие в `logs/audit.log` (JSON-строки с временной меткой). Логи можно собирать в централизованную систему, примонтировав каталог `logs/` в отдельный том.
